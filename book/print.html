<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="deploy.html"><strong aria-hidden="true">1.</strong> Deployment of BotD</a></li><li class="chapter-item expanded "><a href="samuel.html"><strong aria-hidden="true">2.</strong> Deployment of Samuel Code</a></li><li class="chapter-item expanded "><a href="diag.html"><strong aria-hidden="true">3.</strong> Overall architecture</a></li><li class="chapter-item expanded "><a href="oauth.html"><strong aria-hidden="true">4.</strong> OAuth and KeyCloak</a></li><li class="chapter-item expanded "><a href="process.html"><strong aria-hidden="true">5.</strong> Access token and Architecture</a></li><li class="chapter-item expanded "><a href="bug.html"><strong aria-hidden="true">6.</strong> Bug Tracker</a></li><li class="chapter-item expanded "><a href="auth.html"><strong aria-hidden="true">7.</strong> Authentication</a></li><li class="chapter-item expanded "><a href="autho.html"><strong aria-hidden="true">8.</strong> Authorization</a></li><li class="chapter-item expanded "><a href="pkce.html"><strong aria-hidden="true">9.</strong> PKCE</a></li><li class="chapter-item expanded "><a href="bug_pkce.html"><strong aria-hidden="true">10.</strong> Bug tracker with PKCE</a></li><li class="chapter-item expanded "><a href="role.html"><strong aria-hidden="true">11.</strong> Roles</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="deployment-of-fingerprint-botd"><a class="header" href="#deployment-of-fingerprint-botd">Deployment of Fingerprint BotD</a></h1>
<p>BotD is an open source library that detects basic bots in a web browser. It detects the presence of automation tools and frameworks. Deployment of this BotD does not require any server as it runs 100% on the client.</p>
<pre><code>
// Initialize the agent at application startup.
const botdPromise = import('https://openfpcdn.io/botd/v1').then((Botd) => Botd.load())
// Get detection results when you need them.
botdPromise
    .then((botd) => botd.detect())
    .then((result) => console.log(result))
    .catch((error) => console.error(error))
</code></pre>
<p>This JavaScript snippet is designed to integrate and utilize the BotD (Bot Detection) library provided by FingerPrint.</p>
<p>The script is responsible for asynchronously loading the BotD library, initializing the bot detection agent, and retrieving detection results, which can be used to identify and analyze bot activity on a web application.</p>
<p>Promises are used extensively to handle the asynchronous nature of module loading and bot detection. This ensures that each step (loading the module, initializing the agent, performing detection) completes before moving to the next step.</p>
<p>In the final workflow, a user visits the phishing link and must pass the Turnstile authentication to verify they are human. Next, FingerprintJS BotD checks are conducted to prevent bot traffic. Upon successful verification, the user is redirected to the phishing site where their ID and password are captured and stored in the database.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment-of-samuels-code"><a class="header" href="#deployment-of-samuels-code">Deployment of Samuel’s code</a></h1>
<ul>
<li>This set of code was written by Samuel, a senior student of IITM.</li>
<li>It's designed to clean up data about web requests, like extracting dates and simplifying URLs.</li>
<li>It has functionalities for conducting anomaly detection. <p align="center"><strong>Dataset Used</strong></p>
</li>
<li>This is an open source dataset available in Kaggle of an Iranian ecommerce website zanbil.ir.</li>
<li>Heading of the dataset are IP Address, User, Timestamp, Request, Status Code, Bytes Sent, Referrer, User Agent and an Unknown Field indicated mostly by “-”.</li>
<li>This contains more than 1 crore samples. <p align="center"><strong>Creating and Writing Database</strong></p>
</li>
<li>Initial step involves setting up the development environment by installing Go and Julia programming languages, along with their corresponding packages: DataFrame for Julia and SQLite for Go.</li>
<li>Following the setup, we proceed with data preprocessing tasks. Initially, we access the specified access log file and compile a regular expression to extract pertinent information from each log line.</li>
<li>Subsequently, we establish a connection to an SQLite database, "kaggleDataset.db," utilizing the go-sqlite3 driver. Within this database, we commence a transaction to facilitate batch processing of SQL statements.</li>
<li>Next, we ensure the existence of a table named "parsed_data" within the database schema. This table encompasses columns to store IP addresses, requests, user agents, timestamps, status codes, and bytes sent.</li>
<li>We then prepare a SQL query designed to insert parsed data into the "parsed_data" table. This query is instrumental in reading each line of the access log file, parsing it using the previously compiled regular expression, and subsequently inserting the parsed data into the database.</li>
<li>Finally, to persist the changes made to the database, we commit the transaction. This encapsulates the entirety of the data preprocessing pipeline, enabling efficient storage and manipulation of pertinent log data for subsequent analysis and insights. <p align="center"><strong>Data Processing Functions</strong></p>
</li>
</ul>
<p>We have four key functions designed for data processing:</p>
<ol>
<li>appendDate!(logs): This function enhances the DataFrame by incorporating a new column that extracts and appends the date component from a datetime column. For instance, it converts a timestamp like "2023-05-22 15:30:00" to a date format, "2023-05-22".</li>
<li>normalizeRequests!(logs): Here, the focus is on standardizing the request data within the DataFrame. This might entail actions such as scaling numeric columns to a uniform range or converting categorical data into a consistent format. For example, it could ensure that all IP addresses are presented in a consistent case or format.</li>
<li>removeMPrefix!(logs): This function targets the removal of a specific prefix, 'm', from designated fields or entries in the DataFrame. By doing so, it aids in data cleanup, transforming entries like "m12345" to "12345".</li>
<li>removeRapidGrails(logs): This function filters out specific types of data entries or patterns deemed as noise or irrelevant. It's particularly useful for eliminating multiple rapid requests originating from the same IP address within a short timeframe, thus enhancing the overall quality of the dataset.<p align="center"><strong>Data Analysis</strong></p>
</li>
</ol>
<p><strong>Count_stats table</strong></p>
<ul>
<li>This table encapsulates IP address frequency data, presenting the occurrence count of each IP address and facilitates the computation of rankings for individual IP addresses based on their frequency of occurrence.</li>
<li>The occurrence of unusually high request rates or discernible patterns in accessing specific URLs within this dataset may suggest the presence of bot activity.</li>
</ul>
<p><strong>Transition table</strong></p>
<ul>
<li>This involves traversing each row (request) within the provided DataFrame ip_requests.</li>
<li>Subsequently, it constructs a weighted graph wherein each edge signifies a transition from one HTTP request to another, with the weight denoting the frequency of that transition.</li>
<li>Two variables first_request and prev_req are initialized. first_request is set to true to indicate that the current request is the first one, and prev_req is set to nothing to indicate that there is no previous request yet.</li>
<li>For the first request, it sets the ip and prev_req variables based on the IP address and request of the first row.</li>
<li>For each subsequent request, it checks if it's the same as the previous request. If it is, it continues to the next iteration without updating the graph, as transitions from the same request to itself are not considered.</li>
<li>If the current request is different from the previous one, it forms an edge from the previous request to the current one.</li>
<li>The edges of this weighted graph are then sorted in descending order of their weights, utilizing Introsort, a hybrid sorting algorithm amalgamating quicksort, heapsort, and insertion sort.</li>
<li>Upon sorting, the source node, destination node, and weight (frequency) of each edge are extracted from the sorted graph.</li>
<li>Subsequently, a DataFrame named transition_table is generated, housing the source, destination, and weight columns.</li>
<li>These columns encapsulate transitions occurring between HTTP requests, thereby providing a structured representation of the transition dynamics within the dataset.</li>
<li>A dictionary named weighted_graph is initialized to store the weighted edges of the graph.</li>
</ul>
<p><strong>Why is this created</strong></p>
<ul>
<li>This transforms raw web request logs into a structured format, which is pivotal in unveiling the navigation patterns of users as they interact with the website.</li>
<li>Following the generation of the transition table, the subsequent step involves the creation of the 'anomaly_score_raw' table, which calculates an anomaly score for each IP address based on the count of rare transitions.</li>
<li>This is done to pinpoint IP addresses exhibiting a high incidence of uncommon transitions, potentially indicative of anomalous behavior.</li>
<li>Subsequently, the 'anomaly_ratio' table is created to calculate the normalized anomaly score for each IP address by dividing the raw anomaly score by the total number of edges.</li>
<li>This is done to standardize the anomaly scores in relation to the overall activity observed, thereby furnishing a more discernible indicator of anomalous behavior adjusted for the individual activity levels of each IP address.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overall-architecture"><a class="header" href="#overall-architecture">Overall architecture</a></h1>
<p align="center">
  <img src="Image/diag.jpeg" alt="Architecture diagram">
</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oauth"><a class="header" href="#oauth">OAuth</a></h1>
<h2 id="what-is-oauth"><a class="header" href="#what-is-oauth">What is OAuth?</a></h2>
<p>Open Authorization is an open standard protocol for authorization of an application using user information. In general, it allows a third party application access to user related info like name, DOB, email or other required data from an application like Facebook, Google etc. without giving the third party app the user password.</p>
<img src="Image/geek.png" alt="OAuth example" width=400 height=350>
<h2 id="keycloak"><a class="header" href="#keycloak">Keycloak</a></h2>
<ul>
<li>It is an open source Identity and Access Management solution.</li>
<li>It offers features such as Single-Sign-On, Identify Brokering and Social Login, Client Adapters and Account Management Console.</li>
<li>Some alternatives are Okta and Forgerock</li>
</ul>
<p>Advantages:-</p>
<ol>
<li>Open source</li>
<li>Easy customization - configurations</li>
<li>JSON web token - easy to transfer</li>
<li>OpenID and SAML support - standards for SSO</li>
<li>Supports multiple identity provider</li>
</ol>
<p><strong>Installation and Setting</strong></p>
<p>Keycloak can be installed from https://www.keycloak.org/downloads</p>
<p>In Keycloak 17 and later, the traditional standalone.sh script has been replaced with kc.sh. This script is used to manage the Keycloak server, including starting, stopping, and configuring the server.</p>
<p>This starts the Keycloak server in development mode. Development mode typically runs without HTTPS enabled, allowing for easier local testing without the need for SSL certificates and uses an in-memory database by default. This means all data is lost when the server stops. It's convenient for testing but not suitable for persistent storage needs.</p>
<img src="Image/install.png" alt="Keycloak Installation">
<img src="Image/keycloak.png" alt="Keycloak page" height=400>
<p><strong>Components of Keycloak</strong></p>
<ol>
<li>Realm</li>
</ol>
<ul>
<li>A realm in Keycloak acts as a management entity that controls a specific set of users, their credentials, roles, and groups.</li>
<li>It allows for the isolation of data and configurations so that multiple organizations or applications can be managed independently within the same Keycloak instance.</li>
</ul>
<img src="Image/realm.png" alt="Realm settings">
<ol start="2">
<li>Clients</li>
</ol>
<ul>
<li>Clients are entities such as applications or services that can request authentication from users.</li>
<li>They initiate the authentication process and redirect users to Keycloak for login.</li>
</ul>
<img src="Image/clients.png" alt="Clients settings">
<img src="Image/demo-client.png" alt="Demo client">
<ol start="3">
<li>Roles</li>
</ol>
<ul>
<li>Roles in Keycloak serve as identifiers for the type or category of a user.</li>
<li>They help define what actions a user is permitted to perform within the system by assigning permissions associated with specific roles.</li>
</ul>
<img src="Image/realm-role.png" alt="Roles of realm">
<ol start="4">
<li>Users</li>
</ol>
<ul>
<li>Users in Keycloak represent individual user accounts that can log in and interact with the system.</li>
<li>Each user has a unique set of credentials used for authentication.</li>
</ul>
<img src="Image/user.png" alt="User settings">
<img src="Image/oauth-user.png" alt="Oauth user">
<img src="Image/user-role.png" alt="Roles of users">
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-token"><a class="header" href="#access-token">Access Token</a></h1>
<p><strong>What is an access token?</strong></p>
<ul>
<li>An access token in OAuth (Open Authorization) is a credential that is used to authenticate and authorize API requests.</li>
<li>Expiry date of the access token can be extremely low of the order of 30 seconds to 5 minutes.</li>
</ul>
<p>Access Token is divided into</p>
<ol>
<li>
<p>Opaque Token - 1d52703551c84012a7b0af0930092ea6</p>
</li>
<li>
<p>Structured Token (JWT)</p>
</li>
</ol>
<p><strong>Structure of JSON Web Token</strong></p>
<p>// THIS IS THE BODY OF JWT WITHOUT HEADER AND SIGNATURE</p>
<p>{</p>
<p>"exp" : 1700941502,</p>
<p>"iat" : 1700941202,</p>
<p>"auth_time" : 1700941202,</p>
<p>"jti" : "47f9ecbc-f221-4228-acd9-df15f604cb5a",</p>
<p>"iss" : "http://127.0.0.1:9090/realms/oauthcourse",</p>
<p>"sub" : "2fc9115f-75c8-4eea-b1d3-3edd0f3598c2",</p>
<p>"typ" : "Bearer",</p>
<p>"azp" : "bugtracker",</p>
<p>"nonce" : "jvDZ6MnJ7NHJNY2LnuwEXoExnFnppd29ggGa50G0a3c",</p>
<p>"acr" : "1",</p>
<p>"scope" : "openid profile bugtracker.admin email",</p>
<p>"sid" : "15597759-7c5e-4941-945d-629ddf607403",</p>
<p>"email_verified" : false,</p>
<p>"name" : "John Doe",</p>
<p>"preferred_username" : "johndoe",</p>
<p>"given_name" : "John",</p>
<p>"family_name" : "Doe"</p>
<p>}</p>
<h1 id="architecture-diagram"><a class="header" href="#architecture-diagram">Architecture Diagram</a></h1>
<img src="Image/diag.png" alt="Architectural Diagram">
<h2 id="procedure"><a class="header" href="#procedure">Procedure</a></h2>
<ul>
<li>
<p>Main players in the diagram are resource owner, client, authorization server and resource server.</p>
</li>
<li>
<p>Here, user has already logged into the application that is, the client.</p>
</li>
<li>
<p>Now we call this resource API to get the resources associated with the resource owner.</p>
</li>
<li>
<p>We can think about the client as some image editing software.</p>
</li>
<li>
<p>The authorization server as the Google authorization server, and the resource server as the Google Photos API.</p>
</li>
<li>
<p>First, user or resource owner will send the request to connect to the resource server or get the photos of the resource owner.</p>
</li>
<li>
<p>So the client does not know what to do with this and so the client will send an authorized request to the authorization endpoint of the authorization server, asking for the permission to call the resource server on the user's behalf.</p>
</li>
<li>
<p>Authorization request is asking the authorization server to get that authorization from the resource owner.</p>
</li>
<li>
<p>Here, if the user has not already been authorized before, the authorization server will first ask for the user credentials and then specifically ask for permission.</p>
</li>
<li>
<p>Here, authentication is not for logging into our application as we have already logged into the application by other means.</p>
</li>
<li>
<p>The authentication here is only to allow the user to authorize the request to access the resource server.</p>
</li>
<li>
<p>After the resource owner approves it, the authorization server will send a short-lived authorization code (Order of 30s) to the client at its redirection Uri.</p>
</li>
<li>
<p>Also, to authorization server know the redirect Uri when the client was registered, we also provide redirect Uri as part of the registration, basically telling it where to send the authorization code when the authorization request comes in.</p>
</li>
<li>
<p>Client will then send a request to the token endpoint of the authorization server with a grant type of code, and specify the authorization code as part of that request, exchanging the authorization code for an access token.</p>
</li>
<li>
<p>In doing so, the client will have to specify the client ID and the client secret as well, because the authorization server needs to authenticate the client itself.</p>
</li>
</ul>
<p><strong>Why the authorization server does not send the access token directly to the client instead of sending the authorization code?</strong></p>
<ul>
<li>
<p>The reason for this is security.</p>
</li>
<li>
<p>The client is not dealing directly with the authorization server. There's a browser in the middle.</p>
</li>
<li>
<p>It's going through this browser and that makes it less secure.</p>
</li>
<li>
<p>This whole path via the browser is called the front channel and we do not want to expose our access token in that front channel.</p>
</li>
<li>
<p>That's why an authorization code is sent in the front channel and later on, this authorization code is exchanged with the access token in the back channel.</p>
</li>
<li>
<p>The back channel here being the direct communication between the client and the authorization server.</p>
</li>
</ul>
<p><strong>How does the Resource Server verify the token?</strong></p>
<ul>
<li>
<p>If the token is an opaque token, then the resource server will call the authorization server introspection endpoint to make sure that the access token is valid.</p>
</li>
<li>
<p>If the token is a JWT token, then the resource server can do the verification itself.</p>
</li>
<li>
<p>As a part of the verification, it will have to do some important checks the signature verification, the expiry time check and some other checks.</p>
</li>
<li>
<p>The resource server needs a set of public keys to verify the access token.</p>
</li>
<li>
<p>These public keys are provided by the authorization server (the server that issued the access token) through a special endpoint called the JWKS (JSON Web Key Set) endpoint.</p>
</li>
<li>
<p>The access token has three parts: header, payload, and signature.</p>
</li>
<li>
<p>The header of the access token includes a reference to which public key was used to sign the token. This reference is called the Key ID (KId).</p>
</li>
<li>
<p>The resource server looks at the KId in the token's header.</p>
</li>
<li>
<p>It then finds the corresponding public key from the list of public keys retrieved from the JWKS endpoint.</p>
</li>
<li>
<p>Once the correct public key is identified, the resource server uses this key to verify the token's signature.</p>
</li>
<li>
<p>If the signature is valid, the token is considered authentic and the resource server can trust the claims (like user identity and permissions) in the token's payload.</p>
</li>
</ul>
<p><strong>Does that mean that we have to go through this entire process to get an access token every five minutes?</strong></p>
<p>No, here comes the refresh token. If the access token has expired, the client can make a call to the token endpoint again with a grant type of refresh token to get another access token.</p>
<p>A refresh token has a much higher expiry time, at least until the web session ends - let's say 30 minutes.</p>
<p><strong>Limitations</strong></p>
<ul>
<li>This architecture works great if the client or the application is on the back end.</li>
<li>When the client is running inside the browser or a mobile application, it is considered a "public client".</li>
<li>This means it cannot safely store secrets because the client-side environment (browser or mobile app) can be accessed and potentially manipulated by end-users.</li>
<li>To address this issue, the OAuth 2.0 protocol has an extension called PKCE (Proof Key for Code Exchange).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bug-tracker-application"><a class="header" href="#bug-tracker-application">Bug Tracker Application</a></h1>
<p>Bug tracker application is going to be a spring boot application, which supports the functionality of an OAuth client.</p>
<p>This bug tracker application runs on port 8080</p>
<img src="Image/bug.png" alt="Bug tracker phases">
<p>There are two phases of Bug Tracker application - Bug Tracker UI and Bug Tracker API</p>
<ol>
<li>
<p>The UI will be handled by the bug tracker UI application. This is the Spring Boot Controller class, and all the Http requests are first routed to this controller.</p>
</li>
<li>
<p>Any business logic related to the bug tracking will actually be moved to the Bug Tracker API project. The bug tracker API itself will be a Spring Boot Resource server.</p>
</li>
</ol>
<p>As of now, we do not have a database. Everything which is created will be stored in memory within the bug tracker service object.</p>
<p>Essentially, the bug tracking service will act like an in-memory database.</p>
<h1 id="demonstration"><a class="header" href="#demonstration">Demonstration</a></h1>
<p>Logging onto the localhost:8080, we will be redirected to Keycloak login screen</p>
<p><strong>How did that happen?</strong></p>
<p>The URLs in this application are protected.</p>
<p>So the application immediately started the authorization code flow, which means it redirected to the keycloak authorization server, because that's the way it is set up in spring Boot.</p>
<p>Log in using one of the users that we created.</p>
<img src="Image/login.png" alt="Login with user credentials">
<p>When logged in, we'll see the following homepage.</p>
<img src="Image/home.png" alt="Home page of user 'ranga'">
<p>Subject is a unique identifier for the user assigned by Keycloak.</p>
<p>Authorities is spring security specific, which basically maps directly to the privileges in the application.</p>
<p>On the right, lies the tokens. Only the body of the token is displayed, not the headers.</p>
<p>In practical use, we don't display these tokens due to security reasons.</p>
<p><strong>Global Logout</strong></p>
<p>On the right top corner, we could see a logout button. Clicking on logout button, will get us back to keycloak login screen.</p>
<p>This is a global logger, allowing us to not only log out from the application and destroy the session along with cookie removal, it also sends a redirect message to Keycloak to log out from Keycloak as well.</p>
<p>So next time when we try to access the application, we will see the login screen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring-security---oauth-authentication"><a class="header" href="#spring-security---oauth-authentication">Spring Security - OAuth Authentication</a></h1>
<pre><code>
server.port=8080

# Use this pattern to show reduced log width
logging.pattern.console= %d{HH:mm:ss} [%15thread] %msg%n

logging.level.web=TRACE
logging.level.org.springframework.web.client=TRACE

# KeyCloak specific OAuth 2 related properties
spring.security.oauth2.client.registration.keycloak-oidc.provider=keycloak
spring.security.oauth2.client.registration.keycloak-oidc.client-name=bugtracker
spring.security.oauth2.client.registration.keycloak-oidc.client-id=bugtracker
spring.security.oauth2.client.registration.keycloak-oidc.client-secret=VNGk0BtyvKfdwwd8efcjdzr8YisJSEEL
#spring.security.oauth2.client.registration.keycloak-oidc.client-authentication-method=none
spring.security.oauth2.client.registration.keycloak-oidc.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.keycloak-oidc.scope=openid,profile,email

# This represents the Keycloak Provider (issuer is enough for Spring Boot to know all endpoints)
# Openid configuration - http://127.0.0.1:9090/realms/oauthrealm/.well-known/openid-configuration
spring.security.oauth2.client.provider.keycloak.issuer-uri=http://127.0.0.1:8080/realms/oauth
</code></pre>  
<ul>
<li>
<p>Here, we see all the configuration which sets up the application to use Spring Security with Keycloak for OAuth 2.0 authentication, enabling detailed logging for web-related operations and configuring the server to run on port 8080.</p>
</li>
<li>
<p>There are also a bunch of settings related to logging. TRACE is the most detailed logging level, providing extensive information for debugging purposes.</p>
</li>
<li>
<p>Next comes the OAuth 2 related properties specific to Keycloak like client ID, the client secret, the scopes, and the grant type which can be seen in the Clients section of Keycloak server.</p>
</li>
<li>
<p>Last is the location of the provider- keycloak. The only thing necessary is the issuer here which can be found in OpenID endpoint configuration link.</p>
</li>
</ul>
<p><strong>Why?</strong></p>
<p>Knowing the issuer, the spring boot can calculate the .well-known/openID-configuration, and from there it can find out all of the endpoints of Keycloak server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorization-code-grant"><a class="header" href="#authorization-code-grant">Authorization Code Grant</a></h1>
<p>Open an incognito window along with the developer console.</p>
<p>Reason for using incognito is the application of an administrator logged in another window.</p>
<img src="Image/redirect.png" alter="Home page">
<p>When we try to open the Bug tracker application, it redirects us to the login page of Keycloak</p>
<img src="Image/local.png" alter="Localhost section">
<p>On the right, we can see this is the request that we sent to the application and there is a 302 not found, which is basically a redirect request.</p>
<p>So it is redirected to Keycloak Oidc.</p>
<img src="Image/key.png" alter="Keycloak section">
<p>So when we click that, we'll see the request to keycloak-oid.</p>
<p>That is the login request and recognizes that it has to go to Keycloak.</p>
<p>That's why there's a 302 not found and needs to be redirected again.</p>
<img src="Image/auth.png" alter="Authorized link">
<p>Here, in the authorized endpoint, we can see the correct authorization endpoint, response type, client ID and so on.</p>
<p>For additional security, a randomly generated state parameter is also sent.</p>
<p>We will see that state parameter again when the response is returned later, because those need to match.</p>
<p>Nonce is part of the OpenID specification and that's also a randomly generated ID.</p>
<p>When we get the access token, ID token and refresh token, we will see the nonce embedded inside those tokens.</p>
<p>It should match what was sent as part of the authorized request. If not, the response should be rejected.</p>
<img src="Image/full.png" alter="After logged in">
<p>After signing into the application, state parameter that was sent as part of the request is matched here in the redirect URL.</p>
<p>Also, we get the authorization code from this URL, which will go to the token request and get the ID token, the access token and the refresh token.</p>
<img src="Image/log.png" alter="Log entries">
<p>From the log data, we can see a token request being sent with authorization code, and then the code being sent as part of the token request to actually get the token.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-key-for-code-exchange"><a class="header" href="#proof-key-for-code-exchange">Proof Key for Code Exchange</a></h1>
<p><strong>What is the necessity to use PKCE?</strong></p>
<p>The primary issue with authorization code grant type for public clients is the case where a malicious user intercepts the authorization code and somehow knows about the client ID and secret, then that user can use the token endpoint to get an access token, effectively hacking into the resource API.</p>
<p>Since the client secret is not secure for public clients and can be easily obtained by an attacker, relying on it provides no real security.</p>
<p><strong>Proof Key for Code Exchange</strong></p>
<ul>
<li>
<p>Client generates a random code verifier string</p>
<ul>
<li>Unique for that authorized request</li>
<li>Min = 43 chars and Max = 128 chars</li>
<li>Random and impractical to guess</li>
</ul>
</li>
<li>
<p>Once the code verifier is generated, the client generates the code challenge from the code verifier</p>
</li>
</ul>
<p align="center"><strong>code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))</strong></p>
<ul>
<li>Most importantly, we can go from code verifier to code challenge, but not vice-versa due to the inability to get to the original data from hashed SHA256 data.</li>
</ul>
<img src="Image/pkce.png" alt="Flow with PKCE">
<p>This is the same diagram with minor changes when the user clicks on the connect button and just before the authorized request is sent, the client will generate this random code verifier.</p>
<ol>
<li>
<p>The code challenge is created and is sent as part of the authorized request, as part of request 2.</p>
</li>
<li>
<p>The authorization server will generate an authorization code and return the authorization code as part of request 4 as before, but the authorization server will also associate the code challenge with the auth code.</p>
</li>
<li>
<p>Now, when the client sends a token request, it will also send the code verifier.</p>
</li>
<li>
<p>The authorization server will then convert the code verifier to the code challenge using the same Sha256 algorithm.</p>
</li>
<li>
<p>If the code challenge matches with that sent as part of 2, then the authorization server knows that the request is legitimate and it returns the token back.</p>
</li>
</ol>
<p>Code verifier acts like a dynamic secret, only for that particular authorized request for the next authorization request, a different code verifier will be generated by the client.</p>
<p>Using a library like Spring Boot, code verifier and code challenge are automatically generated.</p>
<p>PKCE is recommended for confidential clients as well. When used with confidential clients, the token request would be sent with the client secret as well as the code verifier.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bug-tracker-with-pkce"><a class="header" href="#bug-tracker-with-pkce">Bug Tracker with PKCE</a></h1>
<p>Since we know that PKCE was originally designed so that public clients could use a Code verifier, we are disabling the Client configuration option to make it a public client.</p>
<p>We also select the option of consent required, requiring the user to actually authorize the request.</p>
<img src="Image/bug_pkce.png" alt="Public client" height=350>
<p>Also, select the PKCE challenge method as S256 and save it.</p>
<img src="Image/alg.png" alt="PKCE challenging method" height=120>
<p>We don't need client secret because there is no client secret again. But we will need a client authentication method as none.</p>
<p>This is basically telling Spring Boot that this is a public client.</p>
<pre><code>
# KeyCloak specific OAuth 2 related properties
spring.security.oauth2.client.registration.keycloak-oidc.provider=keycloak
spring.security.oauth2.client.registration.keycloak-oidc.client-name=bugtracker
spring.security.oauth2.client.registration.keycloak-oidc.client-id=bugtracker
# spring.security.oauth2.client.registration.keycloak-oidc.client-secret=VNGk0BtyvKfdwwd8efcjdzr8YisJSEEL
spring.security.oauth2.client.registration.keycloak-oidc.client-authentication-method=none
spring.security.oauth2.client.registration.keycloak-oidc.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.keycloak-oidc.scope=openid,profile,email
</code></pre>
<p>Accessing the application we can see that the code challenge being sent as well as the code challenge method.</p>
<p>This is a sign that PKCE is working.</p>
<img src="Image/public.png" alt="Logging as public client">
<p>It is now asking for authorization and then clicking yes will direct us to home page.</p>
<img src="Image/approve.png" alt="User approval" height=350>
<p>Code verifier is displayed in the request url and in the console logs as shown below</p>
<img src="Image/id.png" alt="Code after logged in">
<p>It sent a Post request to token out here and then we see the code verifier being sent.</p>
<img src="Image/console.png" alt="Same code in console" height=100>
<p>This indicates that PKCE is working great.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bugtracker-authorization-using-roles"><a class="header" href="#bugtracker-authorization-using-roles">BugTracker Authorization using Roles</a></h1>
<ul>
<li>Not all authorization servers are made equal. Keycloak is provided with the ability to map roles to scopes.</li>
<li>This enables us to use scopes in enterprise applications without making changes to Spring Boot's default handling of scopes.</li>
<li>Authorization servers like Okta do not support this mapping.</li>
</ul>
<p>By default, Spring Boot simply takes what is there in the scope claim and creates an authority by prefixing it by scope underscore.</p>
<img src="Image/client.png" alt="Setting roles to client">
<p>Instead of Anyauthority, we assign Anyrole and remove the ROLE_ prefix before each role assigned before.</p>
<pre><code>
@Bean
    public SecurityFilterChain filterChain(HttpSecurity http)
            throws Exception {

            http
                .authorizeHttpRequests(authorize ->
                        authorize
                                .requestMatchers("/bugtracker/ui").authenticated()
                                .requestMatchers("/bugtracker/ui/admin/**").hasAnyRole("bugtracker.admin")
                                .requestMatchers("/bugtracker/ui/**").hasAnyRole("bugtracker.admin", "SCOPE_bugtracker.user")
                                .anyRequest().authenticated())
</code></pre>
<p>We can remove two bug tracker admin and user scopes.</p>
<p>Now, if we login through any of the user, we find that the scope is not included. Only openid, email and profile</p>
<img src="Image/dash.png" alt="Dashboard of user">

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
